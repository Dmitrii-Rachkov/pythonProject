# """ФУНКЦИОНАЛЬНОЕ ПРОГРАММИРОВАНИЕ"""
#
# Создание функций необходимо, чтобы упростить вашу программу, описать повторяющиеся элементы кода,
# которые вы сможете переиспользовать в других местах. Если вы работаете над большим проектом, то
# важно придерживаться принципа Don't Repeat Yourself (DRY, избегайте самоповторов).
# Как один из способов придерживаться данного принципа - использовать циклы и функции.
#
# Этот принцип неразрывно связан с функциональным программированием
#
# Функциональное программирование - парадигма программирования, которая основывается на функциях.
# Одно из ключевых особенностей данной парадигмы это использование функций высшего порядка, которые
# принимают другие функции в качестве аргументов, либо возвращают их как результат.
#
# В Python функция определяется с помощью ключевого слова def. После того, как вы назвали свою
# функцию и поставили круглые скобки, необходимо указать знак двоеточия.
# Следующие строки должны быть с отступом от строки с объявлением функции.

# Например мы с двумя переменными повторяем разные дествия:
x = 9
y = 1
print(x + y)
print(x - y)
# Предположим мы хотим вывести сумму и разность других чисел:
x = 11
y = 10
print(x + y)
print(x - y)

# Всё это мы можем заменить на функцию:
def example(x: int, y: int) -> None:
    print(x + y)
    print(x - y)

example(9, 1)
# в функции в качестве подсказки мы указали тип данных int, но интерпретатор не будет это проверять
# если функция ничего не возвращает, то мы пишем None
# если хотим ещё что-то вернуть можно написать оператор return

# есть также стандартные библиотеки которые можно использовать:
from typing import Any, Dict, List, Union

def welcome(value: Any) -> None:
    if not isinstance(value, str):
        value = str(value)
        print("Your text is" + value)

welcome(2)
# функция isinstance проверяет наше value является ли str типом данных
# если не строка, то переводим value в строку str(value)

"""1.13.1 ПЕРЕДАЧА в функцию неизвестное кол-во аргументов"""

# Эта реализация работает, но всякий раз, когда вы вызываете эту функцию, вам также потребуется
# создать список аргументов для передачи ей.
# Это может быть неудобно, особенно если вы заранее не знаете всех значений, которые должны
# быть включены в список.

# Для этого используется 'args' (позволяет передавать произвольное число неименованных аргументов),
# он может быть полезен, потому что позволяет передавать различное количество аргументов.

# args нужен, когда мы хотим передать неизвестное кол-во неименованных аргументов.
# Еслти поставить * перед именем, это имя будет принимать не один аргумент, а несколько.
# Аргументы передаются как кортеж и доступны внутри функции под тем же именем, что и имя параметра,
# только без *.
# **kwargs - произвольное число именованных аргументов

def summation_1(*args: List[Union[int, float]]) -> Union[int, float]:
    result = 0
    for x in args:
        result += x
    return result

print(summation_1(1, 2, 3))

# Или сокращено написать вот так
def summation_2(*args: List[Union[int, float]]) -> Union[int, float]:
    return sum(args)

print(summation_2(1, 2, 3))

# При помощи **kwargs мы можем передавать в функцию словари, но если используем *args,
# то можем передвать только кортежи, например:
def concatenate(**kwargs: Dict[str, str]) -> str:
    result = ""
    for arg in kwargs.values():
        result += arg + " "
    return result

print(concatenate(a="Real", b="Python", c="Is", d="Great", e="!"))

# Также в эту функцию можно передавать словари:
my_dict = {
    'a': "Real",
    'b': "Python",
    'c': "Is",
    'd': "Great",
    'e': "!",
}

print(concatenate(**my_dict))

# Мы можем обращать к аргументам по ключу:
def show_lastname(**kwarg) -> str:
    print("Her last name is " + kwarg["lname"])

params = {
    'fname': "Nastya",
    'lname': "Nikulina"
}

show_lastname(**params)

