"""Статические и классовые методы"""

# Методы могут быть не только у экземпляра класса, но и у самого класса,
# которые вызываются без какого-то экземпляра (без self).
# Декораторы @staticmethod и @classmethod как раз делают метод таким (статическим или классовым).
# Эти декораторы встроены и видны без import.

# Статический метод – это способ поместить функцию в класс,
# если она логически относится к этому классу.
# Статический метод ничего не знает о классе, из которого его вызвали.
# статический метод не может изменять ни состояние объекта, ни состояние класса.
# Статические методы ограничены в том, к каким данным они могут получить доступ.
# Мы можем вызвать статические методы из самого класса - без предварительного создания экземпляра объекта

class Foo:
    @staticmethod
    def help():
        print('help for Foo class')

Foo.help()

# Классовый метод напротив знает, из какого класса его вызывают.
# Он принимает неявный первый аргумент (обычно его зовут cls),
# который содержит вызывающий класс.
# Классовые методы прекрасно подходят, когда нужно учесть иерархию наследования.
# Пример: метод group создает список из нескольких людей.
# Причем для Person – список Person, а для Worker – список Worker. Со @staticmethod такое бы не вышло:

class Person:

    @classmethod
    def group(cls, n):
        # cls именно тот класс, который вызвал
        return [cls() for _ in range(n)]

    def __repr__(self):
        return 'Person'


class Worker(Person):
    def __repr__(self):
        return 'Worker'


print(Person.group(3))
# [Person, Person, Person]
print(Worker.group(2))
# [Worker, Worker]