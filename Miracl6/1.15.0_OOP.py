"""ОбЪектно-ориентированное программирование (ООП)"""

# ООП - это методология программирования, основанная на представлении программы в виде
# совокупности объектов, каждый из которых является экземпляром определённого класса,
# а классы образуют иерархию наследования.

# Python соответствует принципам ООП. В Python всё является объектами - строки, списки,
# словари и всё остальное.

# Но возможности ООП в python этим не ограничены. Программист может написать свой тип данных (класс),
# определить в нём свои методы.

# Это не является обязательным - мы можем пользоваться только встроенными объектами.
# Однако ООП полезно при долгосрочной разработке программы несколькими людьми, т.к.
# упрощает понимание кода.

"""1.15.1_Абстрация"""

# Абстракция - это выделение основных, наиболее значимых характеристик объекта и игнорирование
# второстепенных.

"""Основные определения"""

# Класс - это некий шаблон для создания объектов, описывает свойства и поведение, которыми
# могут обладать объекты.

# Свойства класса (поля) - это характеристики объекта класса (например цвет или длина).

# Методы класса - это функции, с помощью которых можно оперировать данными класса
# например посчитать производную или сумму.

# Объект (экземпляр класса) - некоторая сущность, реализация какого-то класса, обладающая
# уже определённым состоянием и поведением.

# ВАЖНО!
# Названия классов начинаются с заглавной буквы. Например: MyClass, CatDog

# Создадим наш первый класс:
class Rectangle:
    pass

# После определения класса определим объект класса:
rec = Rectangle()

# Если мы хотим получить доступ к функционалу класса, то должны через точку написать
# интересующий нас метод, например добавим атрибут = 1
r = Rectangle()
# Добавим атрибут:
r.x = 1
print(r.x)
# Можем посмотреть атрибуты объекта:
print(r.__dict__)

# Также доступны встроенные (служебные) атрибуты:
# Документация класса:
print(r.__doc__)
# Словарь в котором храниться пространство имён класса:
print(r.__dict__)
# Список атрибутов класса:
print(r.__dir__())

# Метод __init__ устанавливает начальное состояние, присваивая свойствам значения
# (инициализирует каждый новый экземпляр класса).

# В __init__ также указан self, он необходим чтобы вы закрепили в самом начале адресацию
# на ваши переменные.

# Функция show_perimeter() принимает на вход self - он необходим для получения доступов к
# различным атрибутам экземпляра класса, можно сравнить с некоторым адресом, по
# которому вы можете ориентироваться.

# self - ссылка на текущий экземпляр класса, он необходим для получения доступов к различным
# методам и переменным объявленным в классе. При этом, само имя self не является особенным,
# а лишь договорённостью.

from typing import  Union

class RectangleNew:
    # это атрибуты класса
    # статические поля (свойства или переменные класса)
    color = "green"

    def __init__(self, width: Union[int, float], lenght: Union[int, float]):
        # это атрибуты экземпляра класса
        # динамические поля (свойства или переменные экземпляра класса)
        self.width = width
        self.lenght = lenght
        self.height = 5 # фиксированное значение атрибута
        self.__radius = 20 # атрибут с private защитой '__'

    # метод экземпляра класса (также атрибут)
    def perimeter(self) -> Union[int, float]:
        return (self.width + self.lenght) * 2

    # метод экземпляра класса (также атрибут)
    def show_perimeter(self) -> None:
        print(f"Периметр прямоугольника: {self.perimeter()}")

    # Создадим метод для примера инкапсуляции protected
    def _different(self) -> Union[int, float]:
        return (self.width - self.lenght)

    # Вывод на печать нашей protected функции
    def show_different(self) -> None:
        print(f"Разность сторон: {self._different()}")

    # Метод с защитой private
    def __multi(self) -> Union[int, float]:
        return (self.width * self.lenght)

    # Вывод на печать метода с защитой private
    def show_multi(self) -> None:
        print(f"Мультипликация: {self.__multi()}")

# Создаём нашу фигуру и выводим на печать её периметр:
fig_1 = RectangleNew(1, 2)
fig_1.show_perimeter()

# Просмотрим документацию класса:
print(help(fig_1))

# Посмотрим фиксированное значение атрибута height
print(f"Высота: {fig_1.height}")

"""1.15.2 Инкапсуляция"""

# Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними
# в классе и скрыть детали реализации от пользователя.
#
# Инкапсуляция в python работает лишь на уровне соглашения между программистами о том, какие атрибуты
# являются общедоступными, а какие внутренними.

# Одиночное подчеркивание в начале имени атрибута говорит о том, что переменная или метод не предназначен
# для использования вне методов класса, однако атрибут доступен по этому имени (protected)

# Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным
# по этому имени, но к нему есть доступ только внутри самого класса (private)
fig_2 = RectangleNew(4, 5)
fig_2.show_different()
# Как мы видим метод different нам доступен и всё работает
# Однако в документации этого метода не видно:
print(help(fig_2))
# Одна черта говорит что этот метод лучше не использовать извне

# Двойное подчёркивание в начале имени даёт большую защиту: атрибут становится
# недоступным по этому имени.
fig_3 = RectangleNew(5, 5)
fig_3.show_multi() # могу вывести метод
# print(fig_3.__multi) # не могу вывести метод
# print(fig_3.__radius) # не могу вывести поле

# Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем
# _ИмяКласса__ИмяАтрибута
print(fig_3._RectangleNew__multi())
print(fig_3._RectangleNew__radius)

"""1.15.3_Наследование"""

# Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего
# с частично или полностью заимствующейся функциональностью.
# Класс, от которого производится наследование называется базовым или родительским.
# Новый класс - потомком, наследником или производным классом.

# Давайте скажем, что Rectangle - это будет базовый (родительский) класс, также мы хотим
# создать дочерние классы Cube, который сможет наследовать не только параметры, которые
# мы инициализировали в родительском, но и методы.

# Создадим класс дочериний:
class Cube(RectangleNew):
    def __init__(self, width: int, length: int, skate: int):
        # вызываем метод инициализации из родительского класса
        # чтобы не потерять атрибуты
        super().__init__(width, length)
        self.skate = skate

    # добавим новый метод для вычисления чего-нибудь
    def volume(self) -> int:
        return self.skate * self.width - self.lenght

    # Метод для вывода на печать родительских параметров
    def info_par(self) -> None:
        print(f"width from Paranet = {self.width}")
        print(f"lenght from Parent = {self.lenght}")

    # Переопределим метод периметра для куба
    def show_perimeter(self) -> None:
        print(f"Периметр куба: {self.perimeter()}")

# создаем объект из дочернего класса и выведем на печать
cub = Cube(2, 6, 3)
cub.info_par()

# возьмом метод из родительского класса и применим его к дочернему объекту
cub.show_perimeter()
print(f"Объём куба: {cub.volume()}")

# Метод super() - возвращает прокси-объект, который делегирует вызовы методов
# классу-родителю текущего класса

# Прокси-объект - это объект, который по смыслу должен вести себя так же, как
# замещённый объект

"""1.15.4_Полиморфизм"""

# Мы могли заметить, что изначально в родительском классе изначально было заложено,
# что при вызове метода периметр фигуры, выводится именно слово Прямоугольник,
# давайте переопределим метод show_perimeter() для Cube.
# По сути действие и будет являться с точки зрения ООП полиморфизмом.

# Полиморфизм - использование единственной сущности (метода, оператора или объекта) для
# представления различных типов в различных сценариях использования.
# Пример с переопределением метода show_perimetr() выше

