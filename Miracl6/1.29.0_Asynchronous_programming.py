"""Асинхронное программирование в python"""
import time


# Есть у нас три функции которые никак не связаны между собой и все они запускаются в main():
# Функция print2 имеет продолжительное действие, например запрос к базе данных.
# И функция print3 ждёт когда выполнится функция print2
# Это синхронный код который работает в один поток

def print1():
    print(1)

def print2():
    time.sleep(10)
    print(2)

def print3():
    print(3)

def main():
    print1()
    print2()
    print3()

main()

"""Процесс"""
# Мы можем вывести работу разных функций в разные процессы которые можем увидеть например в
# диспетчере задач.
# Например мы в программе final cut нажимаем на рендеринг видео и он запускает отдельный процесс
# и нагружает например одно ядро процессора.
# При этом программ final cut мне доступна для других действий, т.к. работает уже другой процесс.
# Процесс это отдельно независимая запущенная программа например.

"""Поток"""

# Потоки запускаются в рамках одного процесса, хоть 100 потоков можно запустить.
# И потоки будут конкурировать за ресурсы между собой.
# Python заточен под работу в одном потоке.
# GIL который разрешает работу в один момент времени только одному потоку.
# Если в потоке нечто ожидает time.sleep(10) например, то в таком случае GIL понимает,
# что этот поток спит и ничего не делает, значит я передам управление потоку который
# требует ресурсов.

# Но нужно учитывать, что переключение между потоками тоже занимает время,
# и если у вас большое количество потоков, то многопоточность становится бесполезной
# так она вам не даёт никакого прироста в скорости.

"""Асинхронность"""

# Асинхронность идёт по другому пути.
# Вместо того чтобы плодить потоки, происходит следующее:
# Как только функция чего-то ждёт, она просто приостанавливает свою работу,
# возвращая обещание, что она продолжит работу как только закончится time.sleep()
# Пока функция print2 ожидает, может успешно выполнятся функция print3

# Следующий пример работает без асинхрона.
# Функция query пробегается по всему диску 'C' и печатает в консоль путь.
# Функция clock пишет в консоль вермя каждые 5 секунд.
# И мы видим, что пока функция query не закончит свою работу, clock не выполняется.

import time
import os

def clock():
    time0 = round(time.time())
    while True:
        if (round(time.time()) - time0) % 5 == 0:
            print('5 sec')
            time.sleep(1)

def query():
    for i in os.walk('C:\\'):
        print(i[0])

def main2():
    query()
    clock()

main2()


